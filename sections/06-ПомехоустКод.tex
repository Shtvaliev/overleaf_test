\subsection{Коды, исправляющие ошибки}
Коды, исправляющие ошибки, используются для передачи информации в каналах связи, в которых информация может искажаться. Определенная избыточность в передаваемых кодовых словах (блоках) позволяет обнаруживать ошибки в принятых словах (блоках) и исправлять их, выбирая ближайшие кодовые слова. Особое распространение получили линейные коды в силу более эффективных алгоритмов кодирования и декодирования.
\subsubsection{Определения}
Для начала введем некоторые понятия. Следующие определения взяты из \cite{mal2023}. 
\begin{definition}[Линейный код с параметрами n и k]
 Пусть $F_q$ - конечное поле, состоящее из $q$ элементов, $F_q^n$ - векторное пространство над $F_q$. \textit{Линейным [n, k]-кодом C} называется $k$-мерное векторное подпространство в $F_q^n$.
 При этом вектор $(c_1, c_2, . . . , c_n) \in C$ называется кодовым словом $C$.
\end{definition}
Важным качеством кода является возможность исправления приобретенных в ходе передачи информации по зашумленному каналу ошибок. Для определения кодового расстояния введем метрику на векторном пространстве $F_q^n$.
\begin{definition}[Расстояние Хэмминга]
 \textit{Расстоянием Хэмминга} между векторами $x, y \in F_q^n$ называется число координат, в которых векторы различаются: d$_H(x, y) = |{i \colon x_i \neq y_i}|$. 
\end{definition}
\begin{definition}[Вес Хэмминга]
 \textit{Весом Хэмминга} вектора $x \in F_q^n$ называется число его ненулевых координат: $wt_H(x) = |{i \colon x_i  = 0}| = d_H(x, 0)$.
\end{definition}
\begin{definition}[Кодовое расстояние]
 \textit{Кодовым расстоянием} кода $C$ называется минимальное расстояние Хэмминга между его различными кодовыми словами: $d$ = min\{d$_H(x, y) \colon x, y \in C, x \neq y\}$. 
\end{definition}
В случае линейных кодов имеем $d$ = min\{wt$_H(x) \colon x \in C, x \neq 0\}$. При этом число исправляемых кодом C ошибок равно $t = \lfloor(d - 1)/2\rfloor$.
\begin{definition}[Декодирование]
 \textit{Декодированием} кода C называется отображение $D_C : F_q^n \longrightarrow C$. Код \textit{исправляет t ошибок}, если для всех $e \in F_q^n$ и всех $c \in C$, таких, что wt$_H(e) \leq t$, имеет место $D_C(c + e) = c$.
\end{definition}
\subsubsection{Задача помехоустойчивого кодирования}
\textit{Общую задачу декодирования линейных кодов} можно сформулировать следующим образом. Пусть $C = [n, k] - линейный код над F, y \in F^n$. Тогда необходимо найти $x \in C$, такой, что d$_H(x, y)$ - минимально.\\
Основные методы декодирования:
\begin{itemize}
    \item Метод максимального (наибольшего) правдоподобия\\
    Для полученного вектора $x \in F_q^n$ кодовое слово $c \in C$ подбирается так, чтобы вероятность получить на выходе вектор $x$, отправив изначально $c$, была максимальной.
    \item Декодирование по минимальному расстоянию или до ближайшего кодового слова\\
    Для заданного вектора $x \in F_q^n$ находится $d(x, c)$ по всевозможным кодовым словам $c \in C$. 
\end{itemize}

%Минимальная трудоемкость декодирования ближайшего кодового слова
\subsubsection{Криптосхема Макэлиса}
Первой кодовой криптосистемой была схема шифрования с открытым ключом, предложенная в 1978 г. Р. Макэлисом \cite{me}. Однако практически все асимметричные модификации на базе кодов, предложенные позже, имеют общий недостаток - большие требования к памяти. Согласно \cite{sidelnikov}, существуют два основных предположения относительно безопасности схемы Макэлиса:
\begin{itemize}
    \item Сложность задачи декодирования общего неизвестного кода, которая принадлежит классу NP-трудных \cite{onthe}:\\
    Число t исправляемых ошибок должно быть очень большим, чтобы сделать общие алгоритмы линейного декодирования неэффективными, что является требованием безопасности. Кроме того, криптосистема  может быть модифицирована таким образом, что коэффициент расширения, которому подвергается сообщение, зависил от t. Эта модификация описана в \cite{modif1986}. На пределе, если бы можно было использовать коды достижения пропускной способности, $t$ можно было бы сделать настолько большим, что коэффициент расширения сходился бы к 1.
    \item Сложность атак, восстанавливающих структуру базового кода:\\
   Сложность восстановления структуры кода, заданного произвольной перестановочной матрицей генератора, сильно зависит от рассматриваемого кода. Здесь можно наблюдать интересную дихотомию: в то время как современные коды, основанные на графах (например, LDPC-, expander-, LT- или турбо-коды) небезопасны из-за редких проверок на четность, раскрывающих их структуру, классические алгебраические коды оказались широко устойчивыми к структурным атакам. Наиболее заметное исключение приведено Сидельниковым и Шестаковым в \cite{shest1992}, показывающий, что обобщенные коды Рида-Соломона небезопасны.
\end{itemize}
За счёт этого данная схема имеет применение в постквантовой криптографии.

Согласно \cite{NIST_3-rd}, исходя из размеров открытого и закрытого ключей, классическая схема Макэлиса существенно проигрывает и схеме BIKE \cite{newvariants}, и схеме HQC \cite{effenc}. Несмотря на то, что схема HQC обеспечивает достаточный уровень безопасности, а также разумную частоту отказов при расшифровании, она проигрывает BIKE относительно размеров открытого ключа и зашифрованного текста. А потому схема BIKE показала себя наиболее конкурентоспособной \cite{NIST_3-rd}.